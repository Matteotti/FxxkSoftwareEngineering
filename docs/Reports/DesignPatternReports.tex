\documentclass[24pt,a4paper]{article}% 文档格式
\usepackage{ctex,hyperref}% 输出汉字
\usepackage{times}% 英文使用Times New Roman
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\fontsize{18pt}{27pt}\selectfont% 小四字号，1.5倍行距
	{\heiti% 黑体 
		一种\LaTeX 模板}}% 题目
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\date{}% 日期（这里避免生成日期）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amsfonts,amssymb}% 为公式输入创造条件的宏包
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}% 图片插入宏包
\usepackage{subfigure}% 并排子图
\usepackage{float}% 浮动环境，用于调整图片位置
\usepackage[export]{adjustbox}% 防止过宽的图片
\usepackage{caption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{url}% 超链接
\usepackage{bm}% 加粗部分公式
\usepackage{listings}
\usepackage{xcolor}
\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{orange}
}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{epstopdf}
\usepackage{epsfig}
\usepackage{longtable}% 长表格
\usepackage{supertabular}% 跨页表格
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{changepage}% 换页
\usepackage{listings}% 插入代码段
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[left=2.50cm,right=2.50cm,top=2.80cm,bottom=2.50cm]{geometry}% 页边距设置
\renewcommand{\baselinestretch}{1.5}% 定义行间距（1.5）
\renewcommand{\contentsname}{\normalfont \kaishu \Huge 目录}% 定义目录两字的格式

\usepackage{subfigure}% 有关设置目录引导点的宏包
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % 给 sections加点
\newcommand\mydot[1]{\scalebox{#1}{.}}
\renewcommand\cftdot{\mydot{0.8}} % change the size of dots
\renewcommand\cftdotsep{3} % change the space between dots

\hypersetup{
colorlinks=true,
linkcolor=black
}% 设置链接的颜色，防止目录出现红框
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}% 以下为正文内容
\begin{titlepage}
    \centering
    \includegraphics[width=0.3\textwidth]{image/zju_logo.png}\par\vspace{5cm}
    {\huge\songti 设计模式报告\par}
    \vspace{1cm}
    {\Large\itshape 第三大组第三小组\par}
    \vspace{7cm}

    \vfill
    {\large \today\par}
\end{titlepage}
\newpage

\begin{center}
    \kaishu
    \tableofcontents
    \setcounter{page}{0}
    \thispagestyle{empty} % 设置目录页的页脚为空
\end{center}
\newpage

\section*{\songti 第一部分：观察者模式}
\addcontentsline{toc}{section}{1.观察者模式}
\subsection*{\songti 1.1概念}
\addcontentsline{toc}{subsection}{1.1概念}
观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一
对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象
状态发生变化时，依赖于它的所有观察者都会接收到更新的通知。
\subsection*{\songti 1.2意图}
\addcontentsline{toc}{subsection}{1.2意图}
观察者模式的主要意图是定义对象之间的一种一对多的依赖关系，
当一个对象的状态发生变化时，所有依赖于它的对象都会获得通知并自动更新。

这种模式的目的是为了降低主题和观察者之间的耦合度。主题只需要知道观察
者实现了与之交互的通知接口，并不需要知道观察者的具体实现。

首先，观察者模式允许实现开放-封闭原则，即允许在不修改主题代码的情况下
添加新的观察者。其次，由于主题和观察者之间的解耦，你可以在不影响其它
模块的情况下独立的复用或更换主题或观察者。

总的来说，观察者模式的意图就是通过定义一种弱耦合设计，将变化通知给多
个类，使得它们能够自动进行响应和更新，而无需明确关注彼此的依赖和状态更新情况。
\subsection*{\songti 1.3结构和组成}
\addcontentsline{toc}{subsection}{1.3结构和组成}
观察者模式主要由以下几部分组成：
\subsubsection*{\songti 1.3.1\ 抽象被观察者（Subject）}
定义了一个接口，包含了注册观察者、删除观察者、通知观察者等方法。
\subsubsection*{\songti 1.3.2\ 具体被观察者（ConcreteSubject）}
实现了抽象被观察者接口，维护了一个观察者列表，并在状态发生改变时通知所有注册的观察者。
\subsubsection*{\songti 1.3.3\ 抽象观察者（Observer）}
定义了一个接口，包含了更新状态的方法。
\subsubsection*{\songti 1.3.4\ 具体观察者（ConcreteObserver）}
实现了抽象观察者接口，存储了需要观察的被观察者对象，并在被观察者状态发生改变时进行相应的处理。
\subsection*{\songti 1.4优点和缺点}
\addcontentsline{toc}{subsection}{1.4优点和缺点}

\subsubsection*{\songti 1.4.1\ 优点}
\begin{itemize}
    \item \textbf{避免了紧耦合的关系}：被观察者和观察者对象之间不需要知道对方的具体实现，只
    需要知道对方的接口
    更加简洁和易于使用。
    \item \textbf{增加了灵活性}：由于被观察者对象并不关心具体的观察者是谁，所以在程序运行的
    过程中，可以动态地增加或者删除观察者对象
    \item \textbf{符合开闭原则}：当需要添加新的观察者时，只需要添加一个实现观察者接口的类，
    而不需要修改被观察者对象的代码。
\end{itemize}

\subsubsection*{\songti 1.4.2\ 缺点}
\begin{itemize}
    \item \textbf{内存泄漏}：当观察者没有被正确移除时，可能会导致内存泄漏的问题。
    \item \textbf{程序的复杂度}：实现观察者模式，需要定义多个接口和类，增加了程序的复杂度。
    \item \textbf{循环依赖}在某些情况下，被观察者和观察者对象之间可能出现循环依赖的问题。
\end{itemize}

\subsection*{\songti 1.5应用场景}
\addcontentsline{toc}{subsection}{1.5应用场景}
\begin{enumerate}
    \item 拍卖的时候，拍卖师是观察者，价格是被观察者。拍卖师观察最高标价，然后通知给其他竞价者竞价。
    \item 共享单车：共享单车是被观察者对象，用户是观察者对象。当有新的单车被放置或被租用时，系统会发送给用户通知。
    \item 微信公众号：微信公众号是被观察者对象，粉丝是观察者对象。当公众号发布了新的文章或消息时，系统会发送消息给关注该公众号的粉丝。
\end{enumerate}

\subsection*{\songti 1.6工业界的实际应用}
\addcontentsline{toc}{subsection}{1.6工业界的实际应用}
\begin{enumerate}
    \item \textbf{王者荣耀更新}：当一个对象的状态发生改变时，需要通知多个对象做出相应的响应。例如，王者荣耀更新前，会通知所有用户要更新的时间。
    \item \textbf{发布-订阅}：当很多对象同时对某一个主题感兴趣时，可以采用观察者模式实现发布-订阅模式。例如，生产者发送消息到消息队列中，并通知所有订阅此队列的消费者进行消费。
    \item \textbf{数据库更新}：数据库开发中，当数据库表中的数据发生变化时，需要通知相关的模块进行更新或其他操作。例如，当用户更新了数据库中的某个记录时，就可以通过观察者模式通知所有注册的监听器进行响应。
\end{enumerate}

\subsection*{\songti 1.7本项目中的应用}
\addcontentsline{toc}{subsection}{1.7本项目中的应用}
本项目中，外观类主要运用在工具类和底层数据的使用上。对于一些需要频繁使用的工具类和算法，例如 ThreadLocal、Mail 和 MD5，本项目的后端选择将其集成为工具类，供其他类使用。这样可以大大简化系统代码，并很好地解耦了高级类和低级方法。

一个例子如下
\begin{lstlisting}[language=Java]
@SuppressWarnings("all")
public class ThreadLocalUtil {
    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();
    public static <T> T get() {
        return (T) THREAD_LOCAL.get();
    }
    public static void set(Object value) {
        THREAD_LOCAL.set(value);
    }
    public static void remove() {
        THREAD_LOCAL.remove();
    }
}
\end{lstlisting}
我们将提供线程局部变量的 ThreadLocal 包装为一个外观类，从而简化了其他类对其的使用。

此外，我们还将针对数据库的操作使用观察者模式包装，将数据库操作与业务逻辑分离，使得业务逻辑代码更加清晰和可维护。

一个例子如下：
\begin{lstlisting}[language=Java]
@Mapper
public interface AccountMapper {
    @Update("update account set balance=#{balance} where acno=#{acno}")
    void updateAccount(int acno, double balance);
    
    @Select("select * from account where pano=#{pano}")
    Account findAccountByPano(int pano);
    
    @Select("select Balance from account where pano=#{pano}")
    double findBalanceByPano(int pano);
}
\end{lstlisting}
我们将一些必要的数据库操作包装成一个外观类，在外观类内部通过 @Select 注解指定对应的 SQL 查询语句，实现了对数据库表的操作，并将这些操作作为接口提供给其他类使用。

\newpage
\end{document}
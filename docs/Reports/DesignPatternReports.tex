\documentclass[24pt,a4paper]{article}% 文档格式
\usepackage{ctex,hyperref}% 输出汉字
\usepackage{times}% 英文使用Times New Roman
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\fontsize{18pt}{27pt}\selectfont% 小四字号，1.5倍行距
	{\heiti% 黑体 
		一种\LaTeX 模板}}% 题目
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\date{}% 日期（这里避免生成日期）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amsfonts,amssymb}% 为公式输入创造条件的宏包
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}% 图片插入宏包
\usepackage{subfigure}% 并排子图
\usepackage{float}% 浮动环境，用于调整图片位置
\usepackage[export]{adjustbox}% 防止过宽的图片
\usepackage{caption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{url}% 超链接
\usepackage{bm}% 加粗部分公式
\usepackage{listings}
\usepackage{xcolor}
\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{orange}
}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{epstopdf}
\usepackage{epsfig}
\usepackage{longtable}% 长表格
\usepackage{supertabular}% 跨页表格
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{changepage}% 换页
\usepackage{listings}% 插入代码段
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[left=2.50cm,right=2.50cm,top=2.80cm,bottom=2.50cm]{geometry}% 页边距设置
\renewcommand{\baselinestretch}{1.5}% 定义行间距（1.5）
\renewcommand{\contentsname}{\normalfont \kaishu \Huge 目录}% 定义目录两字的格式

\usepackage{subfigure}% 有关设置目录引导点的宏包
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % 给 sections加点
\newcommand\mydot[1]{\scalebox{#1}{.}}
\renewcommand\cftdot{\mydot{0.8}} % change the size of dots
\renewcommand\cftdotsep{3} % change the space between dots

\hypersetup{
colorlinks=true,
linkcolor=black
}% 设置链接的颜色，防止目录出现红框
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}% 以下为正文内容
\begin{titlepage}
    \centering
    \includegraphics[width=0.3\textwidth]{image/zju_logo.png}\par\vspace{5cm}
    {\huge\songti 设计模式报告\par}
    \vspace{1cm}
    {\Large\itshape 第三大组第三小组\par}
    \vspace{7cm}

    \vfill
    {\large \today\par}
\end{titlepage}
\newpage

\begin{center}
    \kaishu
    \tableofcontents
    \setcounter{page}{0}
    \thispagestyle{empty} % 设置目录页的页脚为空
\end{center}
\newpage

\section*{\songti 第一部分：观察者模式}
\addcontentsline{toc}{section}{1.观察者模式}
\subsection*{\songti 1.1概念}
\addcontentsline{toc}{subsection}{1.1概念}
观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象状态发生变化时，依赖于它的所有观察者都会接收到更新的通知。
\subsection*{\songti 1.2意图}
\addcontentsline{toc}{subsection}{1.2意图}
观察者模式的主要意图是定义对象之间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会获得通知并自动更新。

这种模式的目的是为了降低主题和观察者之间的耦合度。主题只需要知道观察者实现了与之交互的通知接口，并不需要知道观察者的具体实现。

首先，观察者模式允许实现开放-封闭原则，即允许在不修改主题代码的情况下添加新的观察者。其次，由于主题和观察者之间的解耦，你可以在不影响其它模块的情况下独立的复用或更换主题或观察者。

总的来说，观察者模式的意图就是通过定义一种弱耦合设计，将变化通知给多个类，使得它们能够自动进行响应和更新，而无需明确关注彼此的依赖和状态更新情况。

使用观察者模式的好处是，在满足开放封闭原则的前提下，我们可以非常方便地改变主题和观察者，能够适应各种复杂的设计和更新需求。
\subsection*{\songti 1.3结构和组成}
\addcontentsline{toc}{subsection}{1.3结构和组成}
观察者模式主要由以下几部分组成：
\subsubsection*{\songti 1.3.1\ 抽象被观察者（Subject）}
抽象被观察者定义了维护观察者和通知观察者的核心接口。它是被观察者对象的主要参考类型，提供了注册（addObserver）、注销（removeObserver）和通知（notifyObservers）观察者的方法。任何主题对象都可以在需要的时候广播通知。
\subsubsection*{\songti 1.3.2\ 具体被观察者（ConcreteSubject）}
具体被观察者是实现抽象被观察者接口的类。它包含了具体的业务逻辑和状态信息。当状态有任何改变，例如修改了关键数据或者执行了重要的行为，具体被观察者会调用notifyObservers方法，通知所有注册的观察者来取得最新的状态信息。
\subsubsection*{\songti 1.3.3\ 抽象观察者（Observer）}
抽象观察者定义了观察者进行更新的接口，这个接口通常包括一个名为update的方法。所有的观察者都应该实现这个接口，以确保它们可以接收并处理被观察者的通知。
\subsubsection*{\songti 1.3.4\ 具体观察者（ConcreteObserver）}
具体观察者是实现抽象观察者接口的具体类。它保存了一个对具体被观察者的引用，可以获取被观察者的状态。当接收到被观察者的通知，具体观察者会使用update方法来确保它的状态和被观察者的状态保持一致。具体观察者的实现可以根据实际需求进行定制，例如，对于不同类型的通知可能采取不同的行为。
\subsection*{\songti 1.4优点和缺点}
\addcontentsline{toc}{subsection}{1.4优点和缺点}

\subsubsection*{\songti 1.4.1\ 优点}
\begin{itemize}
    \item \textbf{避免了紧耦合的关系}：被观察者和观察者对象之间不需要知道对方的具体实现，只
    需要知道对方的接口
    更加简洁和易于使用。
    \item \textbf{增加了灵活性}：由于被观察者对象并不关心具体的观察者是谁，所以在程序运行的
    过程中，可以动态地增加或者删除观察者对象
    \item \textbf{符合开闭原则}：当需要添加新的观察者时，只需要添加一个实现观察者接口的类，
    而不需要修改被观察者对象的代码。
\end{itemize}

\subsubsection*{\songti 1.4.2\ 缺点}
\begin{itemize}
    \item \textbf{内存泄漏}：当观察者没有被正确移除时，可能会导致内存泄漏的问题。
    \item \textbf{程序的复杂度}：实现观察者模式，需要定义多个接口和类，增加了程序的复杂度。
    \item \textbf{循环依赖}在某些情况下，被观察者和观察者对象之间可能出现循环依赖的问题。
\end{itemize}

\subsection*{\songti 1.5应用场景}
\addcontentsline{toc}{subsection}{1.5应用场景}
\begin{enumerate}
    \item 拍卖的时候，拍卖师是观察者，价格是被观察者。拍卖师观察最高标价，然后通知给其他竞价者竞价。
    \item 共享单车：共享单车是被观察者对象，用户是观察者对象。当有新的单车被放置或被租用时，系统会发送给用户通知。
    \item 微信公众号：微信公众号是被观察者对象，粉丝是观察者对象。当公众号发布了新的文章或消息时，系统会发送消息给关注该公众号的粉丝。
\end{enumerate}

\subsection*{\songti 1.6工业界的实际应用}
\addcontentsline{toc}{subsection}{1.6工业界的实际应用}
\begin{enumerate}
    \item \textbf{事件处理系统}：观察者模式常常被用于实现事件处理系统。在工业生产过程中，例如智能制造、工艺优化和质量控制过程，观察者模式可以实现实时处理和响应各种生产事件。如生产线状态变动、设备故障等情况，所有的观察者（比如工作人员或自动监控系统）都可以立即得到通知并作出响应。
    \item \textbf{订单处理流程}：在工业生产中订单的创建流程，观察者模式可以用来处理订单创建后的一系列操作。一旦订单被创建，就可以通知一系列的观察者（例如库存管理系统、物流系统等）同时进行处理。
    \item \textbf{跨系统通信}：在不同的系统或者进程之间，观察者模式可以以同步阻塞、异步非阻塞的方式进行实现。这种模式能够有效的解耦观察者和被观察者的代码，提高代码的可扩展性和可维护性。
    \item \textbf{机器学习}：在工业制造领域，机器学习也将实现广泛应用，如智能制造、工艺优化和质量控制等。在这些过程中，观察者模式可以帮助系统在某个参数（如设备状态、环境条件等）发生变化时立即通知相关处理模块，这有助于提升工业生产的效率和质量。
\end{enumerate}

\subsection*{\songti 1.7本项目中的应用}
\addcontentsline{toc}{subsection}{1.7本项目中的应用}
本项目中，外观类主要运用在工具类和底层数据的使用上。对于一些需要频繁使用的工具类和算法，例如 ThreadLocal、Mail 和 MD5，本项目的后端选择将其集成为工具类，供其他类使用。这样可以大大简化系统代码，并很好地解耦了高级类和低级方法。

一个例子如下
\begin{lstlisting}[language=Java]
@SuppressWarnings("all")
public class ThreadLocalUtil {
    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();
    public static <T> T get() {
        return (T) THREAD_LOCAL.get();
    }
    public static void set(Object value) {
        THREAD_LOCAL.set(value);
    }
    public static void remove() {
        THREAD_LOCAL.remove();
    }
}
\end{lstlisting}
我们将提供线程局部变量的 ThreadLocal 包装为一个外观类，从而简化了其他类对其的使用。

此外，我们还将针对数据库的操作使用观察者模式包装，将数据库操作与业务逻辑分离，使得业务逻辑代码更加清晰和可维护。

一个例子如下：
\begin{lstlisting}[language=Java]
@Mapper
public interface AccountMapper {
    @Update("update account set balance=#{balance} where acno=#{acno}")
    void updateAccount(int acno, double balance);
    
    @Select("select * from account where pano=#{pano}")
    Account findAccountByPano(int pano);
    
    @Select("select Balance from account where pano=#{pano}")
    double findBalanceByPano(int pano);
}
\end{lstlisting}
我们将一些必要的数据库操作包装成一个外观类，在外观类内部通过 @Select 注解指定对应的 SQL 查询语句，实现了对数据库表的操作，并将这些操作作为接口提供给其他类使用。

\newpage
\end{document}